
 


.set __prev_word_ptr,0

	
	

# Return stack size
#define RET_STACK_SIZE 		4096
# Heap size alloted in BSS
#define HEAP_SIZE 		(32*1024*1024)
# Maximun number of words
#define MAX_NWORD 		256
# Dictionary size (16kb)
#define DICT_SIZE		(16*1024)
# Name table entry size
#define NTAB_ENTRY_SIZE		32
# Word ptr table entry size
#define VTAB_ENTRY_SIZE		2




.section .bss
	
.lcomm _token,NTAB_ENTRY_SIZE
.section .data
_fmt_hex:		.asciz 	"%x"
_fmt_dec:		.asciz 	"%d"
_fmt_float: 		.asciz  "%f"
_fmt_str:		.asciz 	"%s"
_tmp_dec_val:		.long	0
_fmt_Word_not_found:	.asciz 	"Unknown word: '%s'\n"
_var_base:		.long 	10
_code_mode:		.long 	0
_latest:		.long 	__prev_word_ptr
_interpret_bcode:	.byte 0, _code_abort
.globl main

main:
	# Reserve some space for Return stack
	mov	%esp,_vm_param_stack_start
	mov 	%esp,%ebp		
	sub	$RET_STACK_SIZE,%ebp
	mov	%ebp,_vm_return_stack_start

#	call	_show_welcome
# Main loop
_interpet_loop:
	call 	_get_token	# token
	mov 	$_token,%edi
	call 	_find_word
	jnc 	1f		# found word
	
#** CALL(printf,$_fmt_Word_not_found,$token)
	pushal 	
	push $token
	push $_fmt_Word_not_found
	call printf
	addl $8,%esp
	movl %eax,28(%esp)
	popal
#** CALL_END

1f:	
	movl 	$_interpret_bcode,%esi
	movb 	%al,(%esi)		# do it
	
	jmp 	_next_word		# run interpreter


	ret
# edx <- word
# eax -> word_ptr
_find_word:
	mov	_latest, %ebx
1:
	or	%ebx,%ebx
	jz 	1f
	add	$8,%ebx
	
#** CALL(strcmp,%edx,%ebx)
	pushal 	
	push %ebx
	push %edx
	call strcmp
	addl $8,%esp
	movl %eax,28(%esp)
	popal
#** CALL_END

	or	%eax,%eax
	jz	1f
	sub	$4,%ebx
	mov	(%ebx),%ebx
	jmp	1b
1:	mov	%ebx,%eax
	sub	$8,%eax
	ret

	
################################################################################	
# Get token, separated by whites, and put it in _token
# TODO: Make it case insesitive (lowercase everything)
# In:
# Out:	
# eax - integer value
# _token - a token
_get_token:
	
# Skip whites
	call	_get_key_white_skip
	mov 	$_token,%edi
	mov 	$NTAB_ENTRY_SIZE,%ecx
1:	
	dec %ecx			# keep the counter becasue we need to clear out _token
	stosb				# in al we had out character
	call _get_key			# get next key
	call _is_white			# is white?
	jnz 1b				# NO?
	
#** CALL(ungetc,%eax,stdin)
	pushal 	
	push stdin
	push %eax
	call ungetc
	addl $8,%esp
	movl %eax,28(%esp)
	popal
#** CALL_END
	# unget char
	xor 	%eax,%eax		# clear status (not needed?)
	rep 	stosb			# Fill rest of _token
	ret
	
	
	
################################################################################	
# Parse literal, string is in _token
# TODO: Make it work with floats
# In:
# Out:	
# eax - integer value
_parse_literal:
# Check for dot if dot is present then we have floating point number
	push 	%edi
	mov	$_token,%edi
# string length
	xor 	%ecx,%ecx
	not	%ecx
	xor 	%eax,%eax
	cld
	repnz 	scasb
	not 	%ecx
	dec 	%ecx

	mov	$'.',%al
	mov	$_token,%edi
	repnz 	scasb
	jnz	1f	# real

	
#** CALL(sscanf,$_token,$_fmt_float,$_tmp_dec_val)
	pushal 	
	push $_tmp_dec_val
	push $_fmt_float
	push $_token
	call sscanf
	addl $12,%esp
	movl %eax,28(%esp)
	popal
#** CALL_END

	cmp	$0,%eax
	mov 	_tmp_dec_val,%eax
	pop	%edi
	ret
1:
	cmpb	$10,_var_base
	jz	2f
	
#** CALL(sscanf,$_token,$_fmt_hex,$_tmp_dec_val)
	pushal 	
	push $_tmp_dec_val
	push $_fmt_hex
	push $_token
	call sscanf
	addl $12,%esp
	movl %eax,28(%esp)
	popal
#** CALL_END

	cmp	$0,%eax
	mov 	_tmp_dec_val,%eax
	pop	%edi
	ret
2:	
# Use cheap sscanf
	
#** CALL(sscanf,$_token,$_fmt_dec,$_tmp_dec_val)
	pushal 	
	push $_tmp_dec_val
	push $_fmt_dec
	push $_token
	call sscanf
	addl $12,%esp
	movl %eax,28(%esp)
	popal
#** CALL_END

3:	
	cmp	$0,%eax
	mov 	_tmp_dec_val,%eax
	pop	%edi
	ret
	
################################################################################	
# Get key, skipping whites
# In:
# Out:	
# al - an ASCII code of character
# _token - a token
_get_key_white_skip:
	call _get_key
	call _is_white
	jz _get_key_white_skip	# loop until we will find something
	ret

################################################################################	
# Is white?
# In:
# al - an ASCII code of character
# Out:
# Z - if its white
# _token - a token
_is_white:
	cmpb	$10,%al		# CR ?
	jz	1f
	cmpb	$13,%al       	# LF ?
	jz	1f
	cmpb	$9,%al		# TAB ?
	jz	1f
	cmpb	$' ',%al	# SPACE ?
	jz	1f
1:	ret
	
	
################################################################################	
# Get char from STDIN, jumps out in case of EOF
# In:
# Out:
# al - an ASCII code of character
# _token - a token
_get_key:
	
#** CALL(getchar)
	pushal 	
	call getchar
	movl %eax,28(%esp)
	popal
#** CALL_END

	cmp 	$-1,%eax
	jz 	_exit
	cmpb	$10,%al
	jnz 1f
#	push	%eax
#	K4_SAFE_CALL(printf,$_msg_OK)
#	pop	%eax
1:	ret

_next_word:
 	xor 	%eax,%eax		# Clear up %eax
 	lodsl				# load a byte
	add 	$_dict, %eax		# convert dict offset to memory addres
 	jmpl 	*(%eax)			# run the first word
_dict:

	.long	1f
	.long __prev_word_ptr
	.set __prev_word_ptr, . - 8
	.ascii ":code"
	.fill NTAB_ENTRY_SIZE-6
	.byte 0
1:

	call _get_token
	
#** CALL(printf,$_fmt_str,$_token)
	pushal 	
	push $_token
	push $_fmt_str
	call printf
	addl $8,%esp
	movl %eax,28(%esp)
	popal
#** CALL_END


	jmp	_next_word


	.long	1f
	.long __prev_word_ptr
	.set __prev_word_ptr, . - 8
	.ascii "abort"
	.fill NTAB_ENTRY_SIZE-6
	.byte 0
1:

	imp	_interpet_loop

	jmp	_next_word


